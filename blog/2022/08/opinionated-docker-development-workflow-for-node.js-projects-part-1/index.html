<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=description content="You can have a hot-reloading workflow in a Docker container when you are developing your Node.js application."><meta name=author content="Edgar Román"><title>Opinionated Docker development workflow for Node.js projects - Part 1</title><link rel=canonical href=https://romandc.com/blog/2022/08/opinionated-docker-development-workflow-for-node.js-projects-part-1/><script defer data-domain=romandc.com src=https://plausible.io/js/plausible.js></script><meta property="og:title" content="Opinionated Docker development workflow for Node.js projects - Part 1"><meta property="og:description" content="You can have a hot-reloading workflow in a Docker container when you are developing your Node.js application."><meta property="og:type" content="article"><meta property="og:url" content="https://romandc.com/blog/2022/08/opinionated-docker-development-workflow-for-node.js-projects-part-1/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-08-30T00:00:00-04:00"><meta property="article:modified_time" content="2022-08-30T00:00:00-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Opinionated Docker development workflow for Node.js projects - Part 1"><meta name=twitter:description content="You can have a hot-reloading workflow in a Docker container when you are developing your Node.js application."><link rel=stylesheet href=https://romandc.com/css/styles.min.7bb47227462eeeebbc193a825e6cb168407c49db0d7c295e66664efe8532b8eb.css integrity=sha256-e7RyJ0Yu7uu8GTqCXmyxaEB8SdsNfCleZmZO/oUyuOs=></head><body><nav class=bg-gray-800><div class="max-w-7xl mx-auto px-2 sm:px-6 lg:px-8"><div class="relative flex items-center justify-between h-16"><div class="flex-1 flex items-center justify-center sm:items-stretch sm:justify-start"><div class="flex-shrink-0 flex items-center"><a href=https://romandc.com/ class="text-white font-semibold no-underline visited:text-white">Edgar Román</a></div></div><div class="hidden sm:block inset-y-0 right-0 flex space-x-4 items-center pr-2 sm:static sm:inset-auto sm:ml-6 sm:pr-0"><a href=/blog/ class="text-gray-300 hover:bg-gray-700 hover:text-white no-underline visited:text-white px-3 py-2 rounded-md text-sm font-medium">Blog</a>
<a href=/projects/ class="text-gray-300 hover:bg-gray-700 hover:text-white no-underline visited:text-white px-3 py-2 rounded-md text-sm font-medium">Projects</a>
<a href=/tags/ class="text-gray-300 hover:bg-gray-700 hover:text-white no-underline visited:text-white px-3 py-2 rounded-md text-sm font-medium">Tags</a>
<a href=/about/ class="text-gray-300 hover:bg-gray-700 hover:text-white no-underline visited:text-white px-3 py-2 rounded-md text-sm font-medium">About</a></div></div><div class="pb-4 flex flex-wrap justify-center space-x-6 sm:hidden"><a href=/blog/ class="text-gray-300 hover:bg-gray-700 hover:text-white no-underline visited:text-white px-3 py-2 rounded-md text-sm font-medium">Blog</a>
<a href=/projects/ class="text-gray-300 hover:bg-gray-700 hover:text-white no-underline visited:text-white px-3 py-2 rounded-md text-sm font-medium">Projects</a>
<a href=/tags/ class="text-gray-300 hover:bg-gray-700 hover:text-white no-underline visited:text-white px-3 py-2 rounded-md text-sm font-medium">Tags</a>
<a href=/about/ class="text-gray-300 hover:bg-gray-700 hover:text-white no-underline visited:text-white px-3 py-2 rounded-md text-sm font-medium">About</a></div></div></nav><main class=container><div class="relative py-0 bg-white overflow-hidden"><div class="relative px-4 sm:px-6 lg:px-8"><div class="text-lg max-w-prose mx-auto"><h1><span class="block text-3xl text-center leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl">Opinionated Docker development workflow for Node.js projects - Part 1</span>
<span class="block text-base text-center text-indigo-600 font-semibold tracking-wide uppercase"><time datetime=" 2022-08-30T00:00:00-04:00">Tue Aug 30, 2022</time></span>
<span class="block text-base text-center text-indigo-600 font-semibold tracking-wide uppercase py-8"><i class="fa fa-tag" aria-hidden=true></i>
&nbsp;
<span class="inline-flex items-center px-3 py-0.5 rounded-full text-sm font-medium bg-blue-100 text-blue-800"><a href=/tags/docker rel=tag>Docker</a></span>
<span class="inline-flex items-center px-3 py-0.5 rounded-full text-sm font-medium bg-blue-100 text-blue-800"><a href=/tags/serverless rel=tag>Serverless</a></span>
<span class="inline-flex items-center px-3 py-0.5 rounded-full text-sm font-medium bg-blue-100 text-blue-800"><a href=/tags/containers rel=tag>Containers</a></span>
<span class="inline-flex items-center px-3 py-0.5 rounded-full text-sm font-medium bg-blue-100 text-blue-800"><a href=/tags/node rel=tag>Node</a></span></span></h1><p>In a <a href=/blog/2022/08/why-docker-in-2022/>recent post</a>, I described <strong>why</strong> you&rsquo;d want
to use Docker to develop server applications. In this post, I&rsquo;ll describe <strong>how</strong> to
develop a Node.js application with Docker.</p><h1 id=overview>Overview</h1><p>The goals we&rsquo;d like to accomplish in this blog post:</p><ul><li>We are focusing on Node.js environment to write a server side application (e.g. Express, Sails, or other)</li><li>Allow local development without Docker (optional)</li><li>Allow local development with Docker with hot refresh when code changes</li><li>Provide instructions to build images for testing and production</li><li>Isolate container scripts from source code so one folder structure can be used for many projects</li><li>Be straightforward, but explain all the steps so modifications and updates can be made</li></ul><p>This post is divided into two parts:</p><ol><li>How to use the workflow (this post!)</li><li><a href>Dive into the details of how the Dockerfiles work</a></li></ol><p>We&rsquo;ll start with how to use the workflow and readers can continue on to the working details if
interested.</p><h2 id=quick-docker-terminology>Quick Docker Terminology</h2><p>For those who are new to Docker, I use some terms in this post and wanted to quickly define them:</p><p><strong>Dockerfile:</strong> A file that describes a set of instructions to Docker Desktop to build an image.</p><p><strong>Image:</strong> A file that contains the end results of instructions of a Dockerfile after Docker Desktop performs
a build</p><p><strong>Container:</strong> A running instance of your image that can execute code</p><p>That should be enough to get you rolling - let&rsquo;s get to the workflow!</p><h1 id=how-to-use-the-workflow>How to use the workflow</h1><h2 id=directory-structure-and-files>Directory Structure and Files</h2><p>We establish a clear directory structure that isolates all your application specific code into a
single sub-folder and the top level directory holds all the workflow files.</p><p>It looks like this:</p><pre><code>└── Main_Project_Directory/
    ├── server-code/
    │   ├── server.js
    │   ├── package.json
    │   └── ... (All your other source code files)
    ├── .gitignore
    ├── .dockerignore
    ├── Dockerfile
    ├── docker-compose.yml
    └── README.md
</code></pre><blockquote><p>This graph generated on <a href=https://tree.nathanfriend.io/>https://tree.nathanfriend.io/</a></p></blockquote><h3 id=notes><strong>Notes</strong></h3><ul><li>The <code>server-code</code> directory is an arbitrary name.
You may rename it, but be sure to update all the references in the
Dockerfiles and Docker commands shown in this blog post.
The purpose of this subdirectory is to isolate your server code from
all the workflow stuff.</li></ul><ul><li>The <code>Dockerfile</code>, <code>docker-compose.yml</code>, and <code>.dockerignore</code> files will
be taken from <a href=https://github.com/edgarroman/docker-setup-node-container>this repo</a>.</li></ul><h2 id=setup>Setup</h2><p>You&rsquo;ll need to install <a href=https://www.docker.com/products/docker-desktop/>Docker Desktop</a>.</p><p>Clone this repo: <a href=https://github.com/edgarroman/docker-setup-node-container>https://github.com/edgarroman/docker-setup-node-container</a> or just take the Docker related files and build a directory structure as shown above.</p><h3 id=updates>Updates</h3><p>As time goes on, you&rsquo;ll want to modify / upgrade the versions of Node.js and <code>npm</code>. You can find the versions
at the top of the <code>Dockerfile</code>. At the time of this writing the lines look like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=color:#75715e># Base node images can be found here: https://hub.docker.com/_/node?tab=description&amp;amp%3Bpage=1&amp;amp%3Bname=alpine</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ARG</span> NODE_IMAGE<span style=color:#f92672>=</span>node:16.17-alpine<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>For the version of Node.js, head to
<a href="https://hub.docker.com/_/node?tab=description&amp%3Bpage=1&amp%3Bname=alpine">the official node docker hub</a>
and pick your base docker image. I recommend you stick with <strong>alpine</strong> unless you have additional needs.
Replace the 2nd line in the <code>Dockerfile</code> with your desired tag.</p><p>For the npm verison, see line 11. Update this as you see fit.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=color:#66d9ef>ARG</span> NPM_VERSION<span style=color:#f92672>=</span>npm@8.18.0<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>All other versions of packages and whatnot are up to your preferences inside your app.</p><h1 id=workflow-guide>Workflow Guide</h1><p>We&rsquo;ll explore workflows of developing and testing your code. There are a number of workflows that we&rsquo;ll
talk about in this post.</p><ol><li>Local development without containers</li><li>Local development with containers (Preferred)</li><li>Production Build and Local Testing with containers</li></ol><h2 id=local-development-without-containers>Local development without containers</h2><p>This optional workflow does not use Docker at all.
Using this workflow allows you to develop your code locally on your
system with the least number of abstractions and complications. But it also
means you have to install the correct version of Node.js and npm locally.</p><p>Your local system will be directly running Node and directly loading your code.
This workflow requires the least amount of processing power by your machine
and will provide the most responsive development environment.
When you make changes to your code, they be reflected as quickly as possible. (using <code>nodemon</code> to
hot reload your code when changes are detected)</p><p>The downside to this approach is that most likely your local machine
is not running the operating system that your final container will be running.
If you&rsquo;re running Windows, MacOS, or even some flavors of Linux, the packages used locally
may not be identical to those ultimately used in production.</p><p>The differences these packages have between platforms could inject subtle bugs and errors that would be confounding and difficult to debug.
While many straightforward Javascript packages may be identical between platforms,
there also may be differences when your code needs to interact with the host machine&rsquo;s operating system.</p><p>With the pitfalls noted above, why should you take this approach? I would only
recommend this approach if you are working in an environment where running Docker Desktop
puts too much stress on your machine.</p><p>In general, I suggest using the next workflow.</p><h2 id=local-development-with-containers-preferred>Local development with containers (Preferred)</h2><p>This workflow allows you to develop by running your code in a container environment.
This container environment matches exactly what you will be deploying to production. And
you don&rsquo;t need to install anything on your local machine aside from Docker Desktop.</p><p>In addition, if you are working with a team, then you can be assured that regardless
of operating system they are running, the code will behave the same across all
hosts.</p><p>A key benefit of this workflow is that you can edit your source code
and any updates will be reflected in the container. We are still using
<code>nodemon</code> to detect source code changes and reload Node. This greatly eases development
by allowing developers to see changes much faster than having to rebuild the
image on every change.</p><h3 id=steps-to-get-up-and-running>Steps to get up and running</h3><ol><li><p>Start Docker Desktop on your local machine</p></li><li><p>Navigate to the main project directory (not in <code>server-code</code>)</p></li><li><p>If this the first time you are running this workflow, or if you have changed <em>any</em> package dependencies, then run:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>docker compose build
</code></pre></div><p>This step will run <code>npm install</code> in your image and lock in whatever you list in <code>package.json</code>.</p></li><li><p>Now run the following command to create a container (running instance of your image)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>docker compose up
</code></pre></div></li><li><p>You&rsquo;ll be able to see your project running at <a href=http://localhost:8080/>http://localhost:8080/</a>. And you&rsquo;ll be
able to see any logs printed out to the console.</p></li><li><p>Press Control-C to exit the console and stop the container. (Equivalent to <code>docker compose stop</code> if you&rsquo;re familiar
with Docker commands)</p></li><li><p>At this point your container is stopped, but Docker has it ready to start up again just in case. If you&rsquo;re finished
developing or you need to make package changes, type the following to have Docker Desktop do
a complete cleanup. It will remove the container, but keep your image around in case you want to start it again.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>docker compose down
</code></pre></div></li></ol><p><strong>Notes</strong></p><ul><li>If you make any changes to dependent packages, then you&rsquo;ll have to run the <code>docker compose build</code>
command as shown above. <strong>Do this anytime you add, update, or remove a package</strong>.</li><li>We assume that node will be running on port 8080. If this is not the case for your project,
feel free to change it, but make sure to change it everywhere, especially <code>Dockerfile</code> and <code>docker-compose.yml</code>.</li><li>You may find an empty <code>node_modules</code> under the <code>server-code</code> directory. That&rsquo;s ok. When you do a
build, the <code>node_modules</code> directory is created inside your Docker image, but not pulled from your
local machine. So an empty <code>node_modules</code> is normal.</li></ul><h2 id=production-build-and-local-testing-with-containers>Production Build and Local Testing with containers</h2><p>This workflow allows you to test your container by running it locally but with production settings.
It&rsquo;s an exact match of what you would deploy in production, but it allows you to view the
console output to help remove any bugs or errors.</p><p>For this workflow, there is no live reloading of source code.
So if you make a change to the source code, you&rsquo;ll have to run the build step for every change.</p><h3 id=steps-to-get-up-and-running-1>Steps to get up and running</h3><ol><li><p>Start Docker Desktop on your local machine</p></li><li><p>Navigate to the main project directory (not in <code>server-code</code>)</p></li><li><p>To build the image:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>docker build . --target<span style=color:#f92672>=</span>production -t mynodeapp:1.00
</code></pre></div><p>A note here on the name of your image. I&rsquo;ve picked <code>mynodeapp</code> as the name and the version as <code>1.00</code>.
I suggest you call your application something that is meaningful to you and follow <a href=https://semver.org/>semantic
versioning</a></p></li><li><p>To run an instance of your production image locally, run the following command:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>docker run -ti --rm -p 8080:8080 mynodeapp:1.00
</code></pre></div><p>Another note here is that you&rsquo;re running the production version of your application, but most non-trivial
apps will need connectivity to other services such as a database. It&rsquo;s left as an exercise for the reader
to provide such connectivity.</p></li></ol><h3 id=production-deployment>Production Deployment</h3><p>Deploying your production image is outside the scope of this blog post. Especially since it
varies wildly based on your Docker hosting environment.</p><h2 id=conclusion>Conclusion</h2><p>This is end of the first part of this post where we explained how to use this workflow. Part two will
dive into the details of how the Dockerfiles were created and how they enable the workflow.</p></div></div></div></main><footer class=page-footer><div class="footer-copyright text-center py-3">©
<script>document.write((new Date).getFullYear())</script>&nbsp;<a href=/>Edgar Román</a></div></footer></body></html>